# Java基础常见面试题总结(上)

## 基础概念与常识

### Java 语言有哪些特点?

1、基本的面向对象的特点

2、多线程、平台无关性

3、编译与解释并存

### Java SE vs Java EE 分别是什么

Java EE 建立在 Java SE 的基础上，包含了支持企业级应用程序开发和部署的标准和规范

### JVM vs JDK vs JRE

#### JVM的相关简述

JVM的作用JVM的种类（HotSpot VM）

#### JDK 和 JRE

### 什么是字节码?采用字节码的好处是什么?

1、.class文件 2、**Java 程序从源代码到运行的过程**  3、为什么说  **Java 是编译与解释共存的语言** 4、 JDK、JRE、JVM、JIT 这四者的关系如下图所示。

### 为什么说 Java 语言“编译与解释并存”？

什么是**编译型**和**解释型**以及常见的语言有哪些

**为什么说 Java 语言“编译与解释并存”？**

### AOT 有什么优点？为什么不全部使用 AOT 呢？

这种编译模式会在程序被执行前就将其编译成机器码，属于静态编译（C、 C++，Rust，Go 等语言就是静态编译）。AOT 避免了 JIT 预热等各方面的开销，可以提高 Java 程序的启动速度，避免预热时间长。并且，AOT 还能减少内存占用和增强 Java 程序的安全性（AOT 编译后的代码不容易被反编译和修改），特别适合云原生场景。

AOT 的主要优势在于启动时间、内存占用和打包体积。

JIT 的主要优势在于具备更高的极限处理能力，可以降低请求的最大延迟。

**既然 AOT 这么多优点，那为什么不全部使用这种编译方式呢？**

AOT 更适合当下的云原生场景，对微服务架构的支持也比较友好。除此之外，AOT 编译无法支持 Java 的一些动态特性，如反射、动态代理、动态加载、JNI（Java Native Interface）等

### Oracle JDK vs OpenJDK

1. **是否开源**：OpenJDK 是一个参考模型并且是完全开源的，而 Oracle JDK 是基于 OpenJDK 实现的，并不是完全开源的
2. **是否免费**：Oracle JDK 会提供免费版本，但一般有时间限制。OpenJDK 是完全免费的。
3. **功能性**：Oracle JDK 在 OpenJDK 的基础上添加了一些特有的功能和工具，比如 Java Flight Recorder（JFR，一种监控工具）、Java Mission Control（JMC，一种监控工具）等工具。不过，在 Java 11 之后，OracleJDK 和 OpenJDK 的功能基本一致，之前 OracleJDK 中的私有组件大多数也已经被捐赠给开源组织。
4. **稳定性**：OpenJDK 不提供 LTS 服务，而 OracleJDK 大概每三年都会推出一个 LTS 版进行长期支持。
5. **协议**：Oracle JDK 使用 BCL/OTN 协议获得许可，而 OpenJDK 根据 GPL v2 许可获得许可。

### Java 和 C++ 的区别?

指针、单继承和多重继承、自动内存管理垃圾回收机制(GC)、方法重载和操作符重载

## 基本数据类型

###  Java 中的几种基本数据类型了解么？

| 基本类型  | 位数 | 字节 | 默认值  | 取值范围                                                     |
| :-------- | :--- | :--- | :------ | ------------------------------------------------------------ |
| `byte`    | 8    | 1    | 0       | -128 ~ 127                                                   |
| `short`   | 16   | 2    | 0       | -32768（-2^15） ~ 32767（2^15 - 1）                          |
| `int`     | 32   | 4    | 0       | -2147483648 ~ 2147483647                                     |
| `long`    | 64   | 8    | 0L      | -9223372036854775808（-2^63） ~ 9223372036854775807（2^63 -1） |
| `char`    | 16   | 2    | 'u0000' | 0 ~ 65535（2^16 - 1）                                        |
| `float`   | 32   | 4    | 0f      | 1.4E-45 ~ 3.4028235E38                                       |
| `double`  | 64   | 8    | 0d      | 4.9E-324 ~ 1.7976931348623157E308                            |
| `boolean` | 1    |      | false   | true、false                                                  |

### 基本类型和包装类型的区别？

- **用途**：除了定义一些常量和局部变量之外，我们在其他地方比如方法参数、对象属性中很少会使用基本类型来定义变量。并且，包装类型可用于泛型，而基本类型不可以。

- **存储方式**：基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 `static` 修饰 ）存放在 Java 虚拟机的堆中。

- **占用空间**：相比于包装类型（对象类型）， 基本数据类型占用的空间往往非常小。

- **默认值**：成员变量包装类型不赋值就是 `null` ，而基本类型有默认值且不是 `null`。

- **比较方式**：对于基本数据类型来说，`==` 比较的是值。对于包装数据类型来说，`==` 比较的是对象的内存地址。所有整型包装类对象之间值的比较，全部使用 `equals()` 方法。
### 包装类型的缓存机制了解么？

这个缓存机制基于对象池（Object Pool）的概念，旨在减少内存占用和提高性能。
具体来说，Java的包装类缓存了一定范围内的数值，通常在 `-128` 到 `127` 之间的整数。这意味着，如果你使用 `Integer` 包装类创建一个整数对象，且该整数在 `-128` 到 `127` 范围内，那么该对象将在一个对象池中被缓存，下次再创建相同数值的 `Integer` 对象时，会直接返回这个缓存中的对象，而不是创建一个新对象。
这个机制有几个重要的好处：

1. **内存优化**：缓存机制可以减少内存消耗，因为在范围内的整数不会重复创建多个对象，它们都引用缓存中的同一个对象。
2. **性能提升**：因为不需要重复创建对象，缓存机制可以提高性能。比较包装类型的对象时，可以直接比较引用，而不需要比较对象的值。
3. **自动装箱**：这个机制在自动装箱时非常有用，比如 `int` 到 `Integer` 的自动装箱。
但需要注意的是，这个缓存机制只适用于特定范围内的整数。超出这个范围的整数，以及其他包装类型（如 `Double`, `Float`, `Short`, 等）不会享受到这种优化。

### 自动装箱与拆箱了解吗？原理是什么？

**什么是自动拆装箱？**

- **装箱**：将基本类型用它们对应的引用类型包装起来；
- **拆箱**：将包装类型转换为基本数据类型；

### 为什么浮点数运算的时候会有精度丢失的风险？

二进制位在存储某些小数如（0.2）时会出现无限循环的问题，导致存储时只能被截断，所以会出现计算精度问题

### 如何解决浮点数运算的精度丢失问题？

使用`BigDecimal`实现对浮点数的运算

### 超过 long 整型的数据应该如何表示？

使用`BigInteger`存储任意大小的数据类型，常规数值的运算使用会降低效率。

## 变量
###  成员变量与局部变量的区别？
- **语法形式**：XX属于类的，XX是在代码块或方法中定义的变量或是方法的参数；XX可以被 `public`,`private`,`static` 等修饰符所修饰，XX `static` 修饰； XX`final` 所修饰。

- **存储方式**：从变量在内存中的存储方式来看，如果XX是使用 `static` 修饰的，那么XX是属于类的，如果没有使用 `static` 修饰，XX是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。

- **生存时间**：XX是对象的一部分，它随着对象的创建而存在，XX随着方法的调用而自动生成，随着方法的调用结束而消亡。

- **默认值**：XX如果没有被赋初始值，则会自动以类型的默认值而赋值（一种情况例外:被 `final` 修饰的成员变量也必须显式地赋值），XX则不会自动赋值。

**为什么成员变量有默认值？**

1、程序运行 2、默认设置方式 3、编译过程

### 静态变量有什么作用？

一个类的所有对象共享一个静态变量、节省内存

### 字符型常量和字符串常量的区别?
1、**形式** : 单双引号 2、**含义** : XX是值( ASCII 值),可以参加表达式运算; XX是一个地址值(在内存中存放位置)。3、**占内存大小**：XX占 2 个字节; XX占若干个字节。

## 方法

###  什么是方法的返回值?方法有哪几种类型？

执行代码后产生的结果

1、无参无返回值 2、有参无返回值 3、有返回值无参 4、有参有返回值

### 静态方法为什么不能调用非静态成员?

1. 存在时间：静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。

2. 操作逻辑：在类的非静态成员不存在的时候静态方法就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。

### 静态方法和实例方法有何不同？

1、调用方式 2、访问类成员是否存在限制

### 重载和重写有什么区别？

一个方法、不同类的同个方法

在重写中

1. 方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。
2. 如果父类方法访问修饰符为 `private/final/static` 则子类就不能重写该方法，但是被 `static` 修饰的方法能够被再次声明。
3. 构造方法无法被重写

| 区别点     | 重载方法 | 重写方法                                                     |
| :--------- | :------- | :----------------------------------------------------------- |
| 发生范围   | 同一个类 | 子类                                                         |
| 参数列表   | 必须修改 | 一定不能修改                                                 |
| 返回类型   | 可修改   | 子类方法返回值类型应比父类方法返回值类型更小或相等           |
| 异常       | 可修改   | 子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等； |
| 访问修饰符 | 可修改   | 一定不能做更严格的限制（可以降低限制）                       |
| 发生阶段   | 编译期   | 运行期                                                       |

**方法的重写要遵循“两同两小一大”**

- “两同”即方法名相同、形参列表相同；

- “两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；

- “一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。

### 什么是可变长参数？

从 Java5 开始，Java 支持定义可变长参数，所谓可变长参数就是允许在调用方法时传入不定长度的参数。就比如下面的这个 `printVariable` 方法就可以接受 0 个或者多个参数。

```java
public static void method1(String... args) {
   //......
}
```

另外，可变参数只能作为函数的最后一个参数，但其前面可以有也可以没有任何其他参数。

```java
public static void method2(String arg1, String... args) {
   //......
}
```

**遇到方法重载的情况怎么办呢？会优先匹配固定参数还是可变参数的方法呢？**

答案是会优先匹配固定参数的方法，因为固定参数的方法匹配度更高。

# Java基础常见面试题总结(中)

## 面向对象基础

###  面向对象和面向过程的区别

一个将解决问题的过程拆成一个个方法、一个抽象出对象，用对象执行方法的方式解决问题

例子：求圆的面积和周长

### 创建一个对象用什么运算符?对象实体与对象引用有何不同?

对象引用就是实体指向对象的地址（声明）引用（绳子可以系一根气球，也可以不系气球），一个对象可以用多个引用（一个气球可以被多条绳子系着）
