# Java基础常见面试题总结(上)

## 基础概念与常识

### Java 语言有哪些特点?

1、基本的面向对象的特点

2、多线程、平台无关性

3、编译与解释并存

### Java SE vs Java EE 分别是什么

Java EE 建立在 Java SE 的基础上，包含了支持企业级应用程序开发和部署的标准和规范

### JVM vs JDK vs JRE

#### JVM的相关简述

JVM的作用JVM的种类（HotSpot VM）

#### JDK 和 JRE

### 什么是字节码?采用字节码的好处是什么?

1、.class文件 2、**Java 程序从源代码到运行的过程**  3、为什么说  **Java 是编译与解释共存的语言** 4、 JDK、JRE、JVM、JIT 这四者的关系如下图所示。

### 为什么说 Java 语言“编译与解释并存”？

什么是**编译型**和**解释型**以及常见的语言有哪些

**为什么说 Java 语言“编译与解释并存”？**

### AOT 有什么优点？为什么不全部使用 AOT 呢？

这种编译模式会在程序被执行前就将其编译成机器码，属于静态编译（C、 C++，Rust，Go 等语言就是静态编译）。AOT 避免了 JIT 预热等各方面的开销，可以提高 Java 程序的启动速度，避免预热时间长。并且，AOT 还能减少内存占用和增强 Java 程序的安全性（AOT 编译后的代码不容易被反编译和修改），特别适合云原生场景。

AOT 的主要优势在于启动时间、内存占用和打包体积。

JIT 的主要优势在于具备更高的极限处理能力，可以降低请求的最大延迟。

**既然 AOT 这么多优点，那为什么不全部使用这种编译方式呢？**

AOT 更适合当下的云原生场景，对微服务架构的支持也比较友好。除此之外，AOT 编译无法支持 Java 的一些动态特性，如反射、动态代理、动态加载、JNI（Java Native Interface）等

### Oracle JDK vs OpenJDK

1. **是否开源**：OpenJDK 是一个参考模型并且是完全开源的，而 Oracle JDK 是基于 OpenJDK 实现的，并不是完全开源的
2. **是否免费**：Oracle JDK 会提供免费版本，但一般有时间限制。OpenJDK 是完全免费的。
3. **功能性**：Oracle JDK 在 OpenJDK 的基础上添加了一些特有的功能和工具，比如 Java Flight Recorder（JFR，一种监控工具）、Java Mission Control（JMC，一种监控工具）等工具。不过，在 Java 11 之后，OracleJDK 和 OpenJDK 的功能基本一致，之前 OracleJDK 中的私有组件大多数也已经被捐赠给开源组织。
4. **稳定性**：OpenJDK 不提供 LTS 服务，而 OracleJDK 大概每三年都会推出一个 LTS 版进行长期支持。
5. **协议**：Oracle JDK 使用 BCL/OTN 协议获得许可，而 OpenJDK 根据 GPL v2 许可获得许可。

### Java 和 C++ 的区别?

指针、单继承和多重继承、自动内存管理垃圾回收机制(GC)、方法重载和操作符重载

## 基本数据类型

###  Java 中的几种基本数据类型了解么？

| 基本类型  | 位数 | 字节 | 默认值  | 取值范围                                                     |
| :-------- | :--- | :--- | :------ | ------------------------------------------------------------ |
| `byte`    | 8    | 1    | 0       | -128 ~ 127                                                   |
| `short`   | 16   | 2    | 0       | -32768（-2^15） ~ 32767（2^15 - 1）                          |
| `int`     | 32   | 4    | 0       | -2147483648 ~ 2147483647                                     |
| `long`    | 64   | 8    | 0L      | -9223372036854775808（-2^63） ~ 9223372036854775807（2^63 -1） |
| `char`    | 16   | 2    | 'u0000' | 0 ~ 65535（2^16 - 1）                                        |
| `float`   | 32   | 4    | 0f      | 1.4E-45 ~ 3.4028235E38                                       |
| `double`  | 64   | 8    | 0d      | 4.9E-324 ~ 1.7976931348623157E308                            |
| `boolean` | 1    |      | false   | true、false                                                  |

### 基本类型和包装类型的区别？

- **用途**：除了定义一些常量和局部变量之外，我们在其他地方比如方法参数、对象属性中很少会使用基本类型来定义变量。并且，包装类型可用于泛型，而基本类型不可以。

- **存储方式**：基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 `static` 修饰 ）存放在 Java 虚拟机的堆中。

- **占用空间**：相比于包装类型（对象类型）， 基本数据类型占用的空间往往非常小。

- **默认值**：成员变量包装类型不赋值就是 `null` ，而基本类型有默认值且不是 `null`。

- **比较方式**：对于基本数据类型来说，`==` 比较的是值。对于包装数据类型来说，`==` 比较的是对象的内存地址。所有整型包装类对象之间值的比较，全部使用 `equals()` 方法。
### 包装类型的缓存机制了解么？

这个缓存机制基于对象池（Object Pool）的概念，旨在减少内存占用和提高性能。
具体来说，Java的包装类缓存了一定范围内的数值，通常在 `-128` 到 `127` 之间的整数。这意味着，如果你使用 `Integer` 包装类创建一个整数对象，且该整数在 `-128` 到 `127` 范围内，那么该对象将在一个对象池中被缓存，下次再创建相同数值的 `Integer` 对象时，会直接返回这个缓存中的对象，而不是创建一个新对象。
这个机制有几个重要的好处：

1. **内存优化**：缓存机制可以减少内存消耗，因为在范围内的整数不会重复创建多个对象，它们都引用缓存中的同一个对象。
2. **性能提升**：因为不需要重复创建对象，缓存机制可以提高性能。比较包装类型的对象时，可以直接比较引用，而不需要比较对象的值。
3. **自动装箱**：这个机制在自动装箱时非常有用，比如 `int` 到 `Integer` 的自动装箱。
但需要注意的是，这个缓存机制只适用于特定范围内的整数。超出这个范围的整数，以及其他包装类型（如 `Double`, `Float`, `Short`, 等）不会享受到这种优化。

### 自动装箱与拆箱了解吗？原理是什么？

**什么是自动拆装箱？**

- **装箱**：将基本类型用它们对应的引用类型包装起来；
- **拆箱**：将包装类型转换为基本数据类型；

### 为什么浮点数运算的时候会有精度丢失的风险？

二进制位在存储某些小数如（0.2）时会出现无限循环的问题，导致存储时只能被截断，所以会出现计算精度问题

### 如何解决浮点数运算的精度丢失问题？

使用`BigDecimal`实现对浮点数的运算

### 超过 long 整型的数据应该如何表示？

使用`BigInteger`存储任意大小的数据类型，常规数值的运算使用会降低效率。

## 变量
###  成员变量与局部变量的区别？
- **语法形式**：XX属于类的，XX是在代码块或方法中定义的变量或是方法的参数；XX可以被 `public`,`private`,`static` 等修饰符所修饰，XX `static` 修饰； XX`final` 所修饰。

- **存储方式**：从变量在内存中的存储方式来看，如果XX是使用 `static` 修饰的，那么XX是属于类的，如果没有使用 `static` 修饰，XX是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。

- **生存时间**：XX是对象的一部分，它随着对象的创建而存在，XX随着方法的调用而自动生成，随着方法的调用结束而消亡。

- **默认值**：XX如果没有被赋初始值，则会自动以类型的默认值而赋值（一种情况例外:被 `final` 修饰的成员变量也必须显式地赋值），XX则不会自动赋值。

**为什么成员变量有默认值？**

1、程序运行 2、默认设置方式 3、编译过程

### 静态变量有什么作用？

一个类的所有对象共享一个静态变量、节省内存

### 字符型常量和字符串常量的区别?
1、**形式** : 单双引号 2、**含义** : XX是值( ASCII 值),可以参加表达式运算; XX是一个地址值(在内存中存放位置)。3、**占内存大小**：XX占 2 个字节; XX占若干个字节。

## 方法

###  什么是方法的返回值?方法有哪几种类型？

执行代码后产生的结果

1、无参无返回值 2、有参无返回值 3、有返回值无参 4、有参有返回值

### 静态方法为什么不能调用非静态成员?

1. 存在时间：静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。

2. 操作逻辑：在类的非静态成员不存在的时候静态方法就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。

### 静态方法和实例方法有何不同？

1、调用方式 2、访问类成员是否存在限制

### 重载和重写有什么区别？

一个方法、不同类的同个方法

在重写中

1. 方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。
2. 如果父类方法访问修饰符为 `private/final/static` 则子类就不能重写该方法，但是被 `static` 修饰的方法能够被再次声明。
3. 构造方法无法被重写

| 区别点     | 重载方法 | 重写方法                                                     |
| :--------- | :------- | :----------------------------------------------------------- |
| 发生范围   | 同一个类 | 子类                                                         |
| 参数列表   | 必须修改 | 一定不能修改                                                 |
| 返回类型   | 可修改   | 子类方法返回值类型应比父类方法返回值类型更小或相等           |
| 异常       | 可修改   | 子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等； |
| 访问修饰符 | 可修改   | 一定不能做更严格的限制（可以降低限制）                       |
| 发生阶段   | 编译期   | 运行期                                                       |

**方法的重写要遵循“两同两小一大”**

- “两同”即方法名相同、形参列表相同；

- “两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；

- “一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。

### 什么是可变长参数？

从 Java5 开始，Java 支持定义可变长参数，所谓可变长参数就是允许在调用方法时传入不定长度的参数。就比如下面的这个 `printVariable` 方法就可以接受 0 个或者多个参数。

```java
public static void method1(String... args) {
   //......
}
```

另外，可变参数只能作为函数的最后一个参数，但其前面可以有也可以没有任何其他参数。

```java
public static void method2(String arg1, String... args) {
   //......
}
```

**遇到方法重载的情况怎么办呢？会优先匹配固定参数还是可变参数的方法呢？**

答案是会优先匹配固定参数的方法，因为固定参数的方法匹配度更高。

# Java基础常见面试题总结(中)

## 面向对象基础

###  面向对象和面向过程的区别

一个将解决问题的过程拆成一个个方法、一个抽象出对象，用对象执行方法的方式解决问题

例子：求圆的面积和周长

### 创建一个对象用什么运算符?对象实体与对象引用有何不同?

对象引用就是实体指向对象的地址（声明）引用（绳子可以系一根气球，也可以不系气球），一个对象可以用多个引用（一个气球可以被多条绳子系着）

### 对象的相等和引用相等的区别

 存放内容是否相等、内存地址是否相等

### 如果一个类没有声明构造方法，该程序能正确执行吗?

可以、无参

### 构造方法有哪些特点？是否可被 override?

1、名字，返回值，调用 2、不可以，可重载，子类用super调用父类

### 面向对象三大特征

继承、封装、多态

### 接口和抽象类有什么共同点和区别？

共同：都不可被实例化、可以有抽象方法、有默认实现的方法

区别：

- 接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。
- 一个类只能继承一个类，但是可以实现多个接口。
- 接口中的成员变量只能是 `public static final` 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。
 ### 深拷贝和浅拷贝区别了解吗？什么是引用拷贝？

- **浅拷贝**：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。
- **深拷贝**：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。

## Object

###  Object 类的常见方法有哪些？

所有方法的父类、JVM相关getClass、finalize，编程相关hashCode、equals、toString、clone，多线程闲逛notify、notifyAll、wait

### == 和 equals() 的区别

基本数据类型和引用数据类型

### hashCode() 有什么用？

获取哈希码，在使用List等集合数据类型的时候能提高存储效率

### 为什么要有 hashCode？

> 当你把对象加入 `HashSet` 时，`HashSet` 会先计算对象的 `hashCode` 值来判断对象加入的位置，同时也会与其他已经加入的对象的 `hashCode` 值作比较，如果没有相符的 `hashCode`，`HashSet` 会假设对象没有重复出现。但是如果发现有相同 `hashCode` 值的对象，这时会调用 `equals()` 方法来检查 `hashCode` 相等的对象是否真的相同。如果两者相同，`HashSet` 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 `equals` 的次数，相应就大大提高了执行速度。

**那为什么 JDK 还要同时提供这两个方法呢？**

这是因为在一些容器（比如 `HashMap`、`HashSet`）中，有了 `hashCode()` 之后，判断元素是否在对应容器中的效率会更高（参考添加元素进`HashSet`的过程）！

我们在前面也提到了添加元素进`HashSet`的过程，如果 `HashSet` 在对比的时候，同样的 `hashCode` 有多个对象，它会继续使用 `equals()` 来判断是否真的相同。也就是说 `hashCode` 帮助我们大大缩小了查找成本。

**那为什么不只提供 `hashCode()` 方法呢？**

这是因为两个对象的`hashCode` 值相等并不代表两个对象就相等。

**那为什么两个对象有相同的 `hashCode` 值，它们也不一定是相等的？**

因为 `hashCode()` 所使用的哈希算法也许刚好会让多个对象传回相同的哈希值。越糟糕的哈希算法越容易碰撞，但这也与数据值域分布的特性有关（所谓哈希碰撞也就是指的是不同的对象得到相同的 `hashCode` )。

总结下来就是：

- 如果两个对象的`hashCode` 值相等，那这两个对象不一定相等（哈希碰撞）。
- 如果两个对象的`hashCode` 值相等并且`equals()`方法也返回 `true`，我们才认为这两个对象相等。
- 如果两个对象的`hashCode` 值不相等，我们就可以直接认为这两个对象不相等
### 为什么重写 equals() 时必须重写 hashCode() 方法？

- `equals` 方法判断两个对象是相等的，那这两个对象的 `hashCode` 值也要相等。
- 两个对象有相同的 `hashCode` 值，他们也不一定是相等的（哈希碰撞）。
  **思考**：重写 `equals()` 时没有重写 `hashCode()` 方法的话，使用 `HashMap` 可能会出现什么问题。

1. **不符合约定**：在Java中，如果两个对象相等（根据 `equals()` 的定义），它们的 `hashCode()` 值应该相等。这是 `hashCode()` 方法的通用约定，如果没有遵循，它会引发不一致性问题。

2. **哈希表中的元素无法被正确定位**：`HashMap`、`HashSet` 等哈希表数据结构通过 `hashCode()` 来确定元素存储的位置。如果两个相等的对象（根据 `equals()` 的定义）拥有不同的 `hashCode()`，它们将被存储在不同的位置，即使它们应该被视为相等。

3. **无法正确查找对象**：如果一个对象在哈希表中被存储，而在后续查找时它的 `hashCode()` 值发生了变化，那么你将无法通过它来查找对象，因为哈希表无法准确定位到该对象。

## String

### String、StringBuffer、StringBuilder 的区别？

可变性、线程安全性、性能

### String 为什么是不可变的?

1. 保存字符串的数组被 `final` 修饰且为私有的，并且`String` 类没有提供/暴露修改这个字符串的方法。

2. `String` 类被 `final` 修饰导致其不能被继承，进而避免了子类破坏 `String` 不可变。

   在 Java 9 之后，`String`、`StringBuilder` 与 `StringBuffer` 的实现改用 `byte` 数组存储字符串。

### 字符串拼接用“+” 还是 StringBuilder?

可以看出，字符串对象通过“+”的字符串拼接方式，实际上是通过 `StringBuilder` 调用 `append()` 方法实现的，拼接完成之后调用 `toString()` 得到一个 `String` 对象 。

不过，使用 “+” 进行字符串拼接会产生大量的临时对象的问题在 JDK9 中得到了解决。在 JDK9 当中，字符串相加 “+” 改为了用动态方法 `makeConcatWithConstants()` 来实现，而不是大量的 `StringBuilder` 了。

### String#equals() 和 Object#equals() 有何区别？

`String` 中的 `equals` 方法是被重写过的，比较的是 String 字符串的值是否相等。 `Object` 的 `equals` 方法是比较的对象的内存地址。

###  字符串常量池的作用了解吗？

**字符串常量池** 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。

### String s1 = new String("abc");这句话创建了几个字符串对象？

会创建 1 或 2 个字符串对象。

1、如果字符串常量池中不存在字符串对象“abc”的引用，那么它将首先在字符串常量池中创建，然后在堆空间中创建，因此将创建总共 2 个字符串对象。

2、如果字符串常量池中已存在字符串对象“abc”的引用，则只会在堆中创建 1 个字符串对象“abc”。

### String#intern 方法有什么作用?

`String.intern()` 是一个 native（本地）方法，其作用是将指定的字符串对象的引用保存在字符串常量池中，可以简单分为两种情况：

- 如果字符串常量池中保存了对应的字符串对象的引用，就直接返回该引用。
- 如果字符串常量池中没有保存了对应的字符串对象的引用，那就在常量池中创建一个指向该字符串对象的引用并返回。

### String 类型的变量和常量做“+”运算时发生了什么？

先来看字符串不加 `final` 关键字拼接的情况（JDK1.8）：

```java
String str1 = "str";
String str2 = "ing";
String str3 = "str" + "ing";
String str4 = str1 + str2;
String str5 = "string";
System.out.println(str3 == str4);//false
System.out.println(str3 == str5);//true
System.out.println(str4 == str5);//false
```

**对于编译期可以确定值的字符串，也就是常量字符串 ，jvm 会将其存入字符串常量池。并且，字符串常量拼接得到的字符串常量在编译阶段就已经被存放字符串常量池，这个得益于编译器的优化。**

在编译过程中，Javac 编译器（下文中统称为编译器）会进行一个叫做 **常量折叠(Constant Folding)** 的代码优化。

常量折叠会把常量表达式的值求出来作为常量嵌在最终生成的代码中，这是 Javac 编译器会对源代码做的极少量优化措施之一(代码优化几乎都在即时编译器中进行)。

对于 `String str3 = "str" + "ing";` 编译器会给你优化成 `String str3 = "string";` 。

并不是所有的常量都会进行折叠，只有编译器在程序编译期就可以确定值的常量才可以：

- 基本数据类型( `byte`、`boolean`、`short`、`char`、`int`、`float`、`long`、`double`)以及字符串常量。
- `final` 修饰的基本数据类型和字符串变量
- 字符串通过 “+”拼接得到的字符串、基本数据类型之间算数运算（加减乘除）、基本数据类型的位运算（<<、>>、>>> ）
**引用的值在程序编译期是无法确定的，编译器无法对其进行优化。**

对象引用和“+”的字符串拼接方式，实际上是通过 `StringBuilder` 调用 `append()` 方法实现的，拼接完成之后调用 `toString()` 得到一个 `String` 对象 。

```java
String str4 = new StringBuilder().append(str1).append(str2).toString();
```

我们在平时写代码的时候，尽量避免多个字符串对象拼接，因为这样会重新创建对象。如果需要改变字符串的话，可以使用 `StringBuilder` 或者 `StringBuffer`。

不过，字符串使用 `final` 关键字声明之后，可以让编译器当做常量来处理。

示例代码：

```java
final String str1 = "str";
final String str2 = "ing";
// 下面两个表达式其实是等价的
String c = "str" + "ing";// 常量池中的对象
String d = str1 + str2; // 常量池中的对象
System.out.println(c == d);// true
```

被 `final` 关键字修饰之后的 `String` 会被编译器当做常量来处理，编译器在程序编译期就可以确定它的值，其效果就相当于访问常量。

如果 ，编译器在运行时才能知道其确切值的话，就无法对其优化。

示例代码（`str2` 在运行时才能确定其值）：

```java
final String str1 = "str";
final String str2 = getStr();
String c = "str" + "ing";// 常量池中的对象
String d = str1 + str2; // 在堆上创建的新的对象
System.out.println(c == d);// false
public static String getStr() {
      return "ing";
}
```

